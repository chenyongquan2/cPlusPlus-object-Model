#include<iostream>
#include<cstdlib>
#include<functional>
#include <vector>
#include <algorithm>
using namespace std;

class X
{
public:
	int m_x;
	X(const X&temx)
	{
		m_x = temx.m_x;
		cout << "拷贝构造函数被调用" << endl;
	}
	//构造函数
	X()
	{
		m_x = 0;
		cout << "构造函数被调用" << endl;
	}
	~X()//析构函数
	{
		cout << "析构函数被调用" << endl;
	}
	X(int value):m_x(value)//类型转换构造函数
	{
		cout << "类型转换构造函数" << endl;
	}
};


int main(void)
{
	//


	X x10(1000);
	//编译器视角
	//X x10;
	//x10.X::X(1000);
	cout << "000000000000000000000000000000000" << endl;
	X x11 = 1111;//隐式类型转换，调用类型转换构造函数
	
	
	cout << "111111111111111111111111111111111" << endl;

	X x12 = X(1212);
	//d编译器视角
	/*
	X tmp;
	tmp.X::X(1111);//调用构造函数
	x12.X::X(tmp);//拷贝构造函数被调用
	tmp.~X::X();//析构函数被调用
	*/
	cout << "222222222222222222222222222222222" << endl;

	X x13 = (X)1313;
	system("pause");
	return 0;
}
/*
* (1)程序转化语义
类型转换构造函数
000000000000000000000000000000000
类型转换构造函数
111111111111111111111111111111111
类型转换构造函数
222222222222222222222222222222222
类型转换构造函数

结果：全部调用类型转换构造函数，视频演示vs2017是全部调用构造函数
	在linux平台上，不优化的时候，x12是调用拷贝构造函数。第一种x10写法效率最高。
*
* 总结：当编译器面临用一个类对象作为另一个类对象初值的情况，各个编译器表现不同，但是所以编译器都是为了提高效率。
*	我们也没有办法确定编译器是一定调用拷贝构造函数。
*
*问题：拷贝构造函数是否必须有：
*不一定，视情况而定。如果类中只有一些简单的类型，编译器内部支持成员变量的bitwise copy。（编译器本身支持按位拷贝）
****自己写了拷贝构造函数一定要实现拷贝构造函数的功能
*当有指针类型的成员变量指向其他内存，就需要写拷贝构造函数。深拷贝--动态内存分配问题。
* (6)(7)
*/
